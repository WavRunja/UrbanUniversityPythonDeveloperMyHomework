# Задача торты:

# Пит любит испечь пирожные. У него есть несколько рецептов и ингредиентов.
# К сожалению, он не хорош в математике.
# Можете ли вы помочь ему узнать, сколько тортов он мог бы испечь, учитывая его рецепты?
# Написать функцию cakes (), который берет рецепт (объект) и доступные ингредиенты (также объект) и
# возвращает максимальное количество тортов, которые Пит может испечь (целое число).
# Для простоты не существует единиц для количества (например, 1 фунт муки или 200 г сахара - это просто 1
# или 200). Ингредиенты, которых нет в объектах, можно рассматривать как О.

# Примеры:
# must return 2
# cakes ( { flour: 500, sugar: 200, eggs: 1}, { flour: 1200, sugar: 1200, eggs: 5, milk: 200})
# must return 0
# cakes ( { apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100}, { sugar: 500, flour: 2000, milk: 2000})

# Алгоритм решения задачи
# 1. Инициализируем переменную min_cakes для минимального количества тортов.
# 2. Устанавливаем в min_cakes значение бесконечность, сравнения обновят значение до минимального.
# 3. Циклом for пробегаем по каждому ингредиенту в рецепте.
# 4. Проверяем условие if, есть ли этот ингредиент в доступных и достаточно ли его.
# 5. Возвращаем 0, если не можем приготовить ни одного торта.
# 6. Вычисляем количество тортов, которое можно приготовить из доступного количества данного ингредиента,
#    используя целочисленное деление.
# 7. Сравниваем с помощью функции min() и обновляем минимальное количество тортов.
# 8. После завершения цикла, возвращаем минимальное количество тортов.

# определение торты(рецепт, доступно):
#     минимум_тортов = бесконечность
#
#     для ингредиента, необходимое_количество из рецепта.пары_элементов():
#         если ингредиент не в доступен или доступный[ингредиент] < необходимого_количества:
#             вернуть 0
#
#         возможное_количество = доступный[ингредиент] // необходимое_количество
#
#         минимум_тортов = минимум(минимум_тортов, возможное_количество)
#
#     вернуть минимум_тортов
#
# первый_ответ = торты({'мука': 500, 'сахар': 200, 'яйца': 1},
#             {'мука': 1200, 'сахар': 1200, 'яйца': 5, 'молоко': 200})
# второй_ответ = торты({'яблоки': 3, 'мука': 300, 'сахар': 150, 'молоко': 100, 'масло': 100},
#             {'сахар': 500, 'мука': 2000, 'молоко': 2000})
#
# # первый_ответ вернет 2
# # второй_ответ вернет 0
# напечатать (f" {первый_ответ} \n {второй_ответ}")

def cakes(recipe, available):
    # Инициализируем переменную для минимального количества тортов
    min_cakes = float('inf') # Устанавливаем бесконечность, сравнения обновят значение до минимального.
    # print(min_cakes)

    # Пробегаем по каждому ингредиенту в рецепте
    for ingredient, amount_needed in recipe.items():
        # Проверяем, есть ли этот ингредиент в доступных и достаточно ли его
        if ingredient not in available or available[ingredient] < amount_needed:
            return 0  # Не можем приготовить ни одного торта

        # Вычисляем количество тортов, которое можно приготовить из доступного количества данного ингредиента
        amount_possible = available[ingredient] // amount_needed

        # Обновляем минимальное количество тортов
        min_cakes = min(min_cakes, amount_possible)

    # Возвращаем минимальное количество тортов
    return min_cakes


# Примеры использования
answer1 = cakes({'flour': 500, 'sugar': 200, 'eggs': 1},
            {'flour': 1200, 'sugar': 1200, 'eggs': 5, 'milk': 200})
answer2 = cakes({'apples': 3, 'flour': 300, 'sugar': 150, 'milk': 100, 'oil': 100},
            {'sugar': 500, 'flour': 2000, 'milk': 2000})

# answer1 must return 2
# answer2 must return 0
print (f" {answer1} \n {answer2}")
